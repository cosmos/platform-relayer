// Code generated by mockery. DO NOT EDIT.

package ibcv2

import (
	context "context"
	big "math/big"

	config "github.com/cosmos/ibc-relayer/shared/config"

	db "github.com/cosmos/ibc-relayer/db/gen/db"

	ibcv2 "github.com/cosmos/ibc-relayer/shared/bridges/ibcv2"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// MockBridgeClient is an autogenerated mock type for the BridgeClient type
type MockBridgeClient struct {
	mock.Mock
}

type MockBridgeClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBridgeClient) EXPECT() *MockBridgeClient_Expecter {
	return &MockBridgeClient_Expecter{mock: &_m.Mock}
}

// ChainType provides a mock function with no fields
func (_m *MockBridgeClient) ChainType() config.ChainType {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ChainType")
	}

	var r0 config.ChainType
	if rf, ok := ret.Get(0).(func() config.ChainType); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(config.ChainType)
	}

	return r0
}

// MockBridgeClient_ChainType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChainType'
type MockBridgeClient_ChainType_Call struct {
	*mock.Call
}

// ChainType is a helper method to define mock.On call
func (_e *MockBridgeClient_Expecter) ChainType() *MockBridgeClient_ChainType_Call {
	return &MockBridgeClient_ChainType_Call{Call: _e.mock.On("ChainType")}
}

func (_c *MockBridgeClient_ChainType_Call) Run(run func()) *MockBridgeClient_ChainType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockBridgeClient_ChainType_Call) Return(_a0 config.ChainType) *MockBridgeClient_ChainType_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBridgeClient_ChainType_Call) RunAndReturn(run func() config.ChainType) *MockBridgeClient_ChainType_Call {
	_c.Call.Return(run)
	return _c
}

// ClientState provides a mock function with given fields: ctx, clientID
func (_m *MockBridgeClient) ClientState(ctx context.Context, clientID string) (ibcv2.ClientState, error) {
	ret := _m.Called(ctx, clientID)

	if len(ret) == 0 {
		panic("no return value specified for ClientState")
	}

	var r0 ibcv2.ClientState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (ibcv2.ClientState, error)); ok {
		return rf(ctx, clientID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) ibcv2.ClientState); ok {
		r0 = rf(ctx, clientID)
	} else {
		r0 = ret.Get(0).(ibcv2.ClientState)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, clientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_ClientState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ClientState'
type MockBridgeClient_ClientState_Call struct {
	*mock.Call
}

// ClientState is a helper method to define mock.On call
//   - ctx context.Context
//   - clientID string
func (_e *MockBridgeClient_Expecter) ClientState(ctx interface{}, clientID interface{}) *MockBridgeClient_ClientState_Call {
	return &MockBridgeClient_ClientState_Call{Call: _e.mock.On("ClientState", ctx, clientID)}
}

func (_c *MockBridgeClient_ClientState_Call) Run(run func(ctx context.Context, clientID string)) *MockBridgeClient_ClientState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockBridgeClient_ClientState_Call) Return(_a0 ibcv2.ClientState, _a1 error) *MockBridgeClient_ClientState_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_ClientState_Call) RunAndReturn(run func(context.Context, string) (ibcv2.ClientState, error)) *MockBridgeClient_ClientState_Call {
	_c.Call.Return(run)
	return _c
}

// DeliverTx provides a mock function with given fields: ctx, tx, address
func (_m *MockBridgeClient) DeliverTx(ctx context.Context, tx []byte, address string) (*ibcv2.BridgeTx, error) {
	ret := _m.Called(ctx, tx, address)

	if len(ret) == 0 {
		panic("no return value specified for DeliverTx")
	}

	var r0 *ibcv2.BridgeTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte, string) (*ibcv2.BridgeTx, error)); ok {
		return rf(ctx, tx, address)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte, string) *ibcv2.BridgeTx); ok {
		r0 = rf(ctx, tx, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ibcv2.BridgeTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte, string) error); ok {
		r1 = rf(ctx, tx, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_DeliverTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeliverTx'
type MockBridgeClient_DeliverTx_Call struct {
	*mock.Call
}

// DeliverTx is a helper method to define mock.On call
//   - ctx context.Context
//   - tx []byte
//   - address string
func (_e *MockBridgeClient_Expecter) DeliverTx(ctx interface{}, tx interface{}, address interface{}) *MockBridgeClient_DeliverTx_Call {
	return &MockBridgeClient_DeliverTx_Call{Call: _e.mock.On("DeliverTx", ctx, tx, address)}
}

func (_c *MockBridgeClient_DeliverTx_Call) Run(run func(ctx context.Context, tx []byte, address string)) *MockBridgeClient_DeliverTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte), args[2].(string))
	})
	return _c
}

func (_c *MockBridgeClient_DeliverTx_Call) Return(_a0 *ibcv2.BridgeTx, _a1 error) *MockBridgeClient_DeliverTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_DeliverTx_Call) RunAndReturn(run func(context.Context, []byte, string) (*ibcv2.BridgeTx, error)) *MockBridgeClient_DeliverTx_Call {
	_c.Call.Return(run)
	return _c
}

// FindAckTx provides a mock function with given fields: ctx, sourceClientID, destClientID, sequence
func (_m *MockBridgeClient) FindAckTx(ctx context.Context, sourceClientID string, destClientID string, sequence uint64) (*ibcv2.BridgeTx, error) {
	ret := _m.Called(ctx, sourceClientID, destClientID, sequence)

	if len(ret) == 0 {
		panic("no return value specified for FindAckTx")
	}

	var r0 *ibcv2.BridgeTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64) (*ibcv2.BridgeTx, error)); ok {
		return rf(ctx, sourceClientID, destClientID, sequence)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64) *ibcv2.BridgeTx); ok {
		r0 = rf(ctx, sourceClientID, destClientID, sequence)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ibcv2.BridgeTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, uint64) error); ok {
		r1 = rf(ctx, sourceClientID, destClientID, sequence)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_FindAckTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindAckTx'
type MockBridgeClient_FindAckTx_Call struct {
	*mock.Call
}

// FindAckTx is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceClientID string
//   - destClientID string
//   - sequence uint64
func (_e *MockBridgeClient_Expecter) FindAckTx(ctx interface{}, sourceClientID interface{}, destClientID interface{}, sequence interface{}) *MockBridgeClient_FindAckTx_Call {
	return &MockBridgeClient_FindAckTx_Call{Call: _e.mock.On("FindAckTx", ctx, sourceClientID, destClientID, sequence)}
}

func (_c *MockBridgeClient_FindAckTx_Call) Run(run func(ctx context.Context, sourceClientID string, destClientID string, sequence uint64)) *MockBridgeClient_FindAckTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(uint64))
	})
	return _c
}

func (_c *MockBridgeClient_FindAckTx_Call) Return(_a0 *ibcv2.BridgeTx, _a1 error) *MockBridgeClient_FindAckTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_FindAckTx_Call) RunAndReturn(run func(context.Context, string, string, uint64) (*ibcv2.BridgeTx, error)) *MockBridgeClient_FindAckTx_Call {
	_c.Call.Return(run)
	return _c
}

// FindRecvTx provides a mock function with given fields: ctx, sourceClientID, destClientID, sequence, timeoutTimestamp
func (_m *MockBridgeClient) FindRecvTx(ctx context.Context, sourceClientID string, destClientID string, sequence uint64, timeoutTimestamp time.Time) (*ibcv2.BridgeTx, error) {
	ret := _m.Called(ctx, sourceClientID, destClientID, sequence, timeoutTimestamp)

	if len(ret) == 0 {
		panic("no return value specified for FindRecvTx")
	}

	var r0 *ibcv2.BridgeTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64, time.Time) (*ibcv2.BridgeTx, error)); ok {
		return rf(ctx, sourceClientID, destClientID, sequence, timeoutTimestamp)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64, time.Time) *ibcv2.BridgeTx); ok {
		r0 = rf(ctx, sourceClientID, destClientID, sequence, timeoutTimestamp)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ibcv2.BridgeTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, uint64, time.Time) error); ok {
		r1 = rf(ctx, sourceClientID, destClientID, sequence, timeoutTimestamp)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_FindRecvTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindRecvTx'
type MockBridgeClient_FindRecvTx_Call struct {
	*mock.Call
}

// FindRecvTx is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceClientID string
//   - destClientID string
//   - sequence uint64
//   - timeoutTimestamp time.Time
func (_e *MockBridgeClient_Expecter) FindRecvTx(ctx interface{}, sourceClientID interface{}, destClientID interface{}, sequence interface{}, timeoutTimestamp interface{}) *MockBridgeClient_FindRecvTx_Call {
	return &MockBridgeClient_FindRecvTx_Call{Call: _e.mock.On("FindRecvTx", ctx, sourceClientID, destClientID, sequence, timeoutTimestamp)}
}

func (_c *MockBridgeClient_FindRecvTx_Call) Run(run func(ctx context.Context, sourceClientID string, destClientID string, sequence uint64, timeoutTimestamp time.Time)) *MockBridgeClient_FindRecvTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(uint64), args[4].(time.Time))
	})
	return _c
}

func (_c *MockBridgeClient_FindRecvTx_Call) Return(_a0 *ibcv2.BridgeTx, _a1 error) *MockBridgeClient_FindRecvTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_FindRecvTx_Call) RunAndReturn(run func(context.Context, string, string, uint64, time.Time) (*ibcv2.BridgeTx, error)) *MockBridgeClient_FindRecvTx_Call {
	_c.Call.Return(run)
	return _c
}

// FindTimeoutTx provides a mock function with given fields: ctx, sourceClientID, destClientID, sequence
func (_m *MockBridgeClient) FindTimeoutTx(ctx context.Context, sourceClientID string, destClientID string, sequence uint64) (*ibcv2.BridgeTx, error) {
	ret := _m.Called(ctx, sourceClientID, destClientID, sequence)

	if len(ret) == 0 {
		panic("no return value specified for FindTimeoutTx")
	}

	var r0 *ibcv2.BridgeTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64) (*ibcv2.BridgeTx, error)); ok {
		return rf(ctx, sourceClientID, destClientID, sequence)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, uint64) *ibcv2.BridgeTx); ok {
		r0 = rf(ctx, sourceClientID, destClientID, sequence)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ibcv2.BridgeTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, uint64) error); ok {
		r1 = rf(ctx, sourceClientID, destClientID, sequence)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_FindTimeoutTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindTimeoutTx'
type MockBridgeClient_FindTimeoutTx_Call struct {
	*mock.Call
}

// FindTimeoutTx is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceClientID string
//   - destClientID string
//   - sequence uint64
func (_e *MockBridgeClient_Expecter) FindTimeoutTx(ctx interface{}, sourceClientID interface{}, destClientID interface{}, sequence interface{}) *MockBridgeClient_FindTimeoutTx_Call {
	return &MockBridgeClient_FindTimeoutTx_Call{Call: _e.mock.On("FindTimeoutTx", ctx, sourceClientID, destClientID, sequence)}
}

func (_c *MockBridgeClient_FindTimeoutTx_Call) Run(run func(ctx context.Context, sourceClientID string, destClientID string, sequence uint64)) *MockBridgeClient_FindTimeoutTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(uint64))
	})
	return _c
}

func (_c *MockBridgeClient_FindTimeoutTx_Call) Return(_a0 *ibcv2.BridgeTx, _a1 error) *MockBridgeClient_FindTimeoutTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_FindTimeoutTx_Call) RunAndReturn(run func(context.Context, string, string, uint64) (*ibcv2.BridgeTx, error)) *MockBridgeClient_FindTimeoutTx_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransactionSender provides a mock function with given fields: ctx, hash
func (_m *MockBridgeClient) GetTransactionSender(ctx context.Context, hash string) (string, error) {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionSender")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, hash)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_GetTransactionSender_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransactionSender'
type MockBridgeClient_GetTransactionSender_Call struct {
	*mock.Call
}

// GetTransactionSender is a helper method to define mock.On call
//   - ctx context.Context
//   - hash string
func (_e *MockBridgeClient_Expecter) GetTransactionSender(ctx interface{}, hash interface{}) *MockBridgeClient_GetTransactionSender_Call {
	return &MockBridgeClient_GetTransactionSender_Call{Call: _e.mock.On("GetTransactionSender", ctx, hash)}
}

func (_c *MockBridgeClient_GetTransactionSender_Call) Run(run func(ctx context.Context, hash string)) *MockBridgeClient_GetTransactionSender_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockBridgeClient_GetTransactionSender_Call) Return(_a0 string, _a1 error) *MockBridgeClient_GetTransactionSender_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_GetTransactionSender_Call) RunAndReturn(run func(context.Context, string) (string, error)) *MockBridgeClient_GetTransactionSender_Call {
	_c.Call.Return(run)
	return _c
}

// IsPacketCommitted provides a mock function with given fields: ctx, clientID, sequence
func (_m *MockBridgeClient) IsPacketCommitted(ctx context.Context, clientID string, sequence uint64) (bool, error) {
	ret := _m.Called(ctx, clientID, sequence)

	if len(ret) == 0 {
		panic("no return value specified for IsPacketCommitted")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) (bool, error)); ok {
		return rf(ctx, clientID, sequence)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) bool); ok {
		r0 = rf(ctx, clientID, sequence)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint64) error); ok {
		r1 = rf(ctx, clientID, sequence)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_IsPacketCommitted_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsPacketCommitted'
type MockBridgeClient_IsPacketCommitted_Call struct {
	*mock.Call
}

// IsPacketCommitted is a helper method to define mock.On call
//   - ctx context.Context
//   - clientID string
//   - sequence uint64
func (_e *MockBridgeClient_Expecter) IsPacketCommitted(ctx interface{}, clientID interface{}, sequence interface{}) *MockBridgeClient_IsPacketCommitted_Call {
	return &MockBridgeClient_IsPacketCommitted_Call{Call: _e.mock.On("IsPacketCommitted", ctx, clientID, sequence)}
}

func (_c *MockBridgeClient_IsPacketCommitted_Call) Run(run func(ctx context.Context, clientID string, sequence uint64)) *MockBridgeClient_IsPacketCommitted_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64))
	})
	return _c
}

func (_c *MockBridgeClient_IsPacketCommitted_Call) Return(_a0 bool, _a1 error) *MockBridgeClient_IsPacketCommitted_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_IsPacketCommitted_Call) RunAndReturn(run func(context.Context, string, uint64) (bool, error)) *MockBridgeClient_IsPacketCommitted_Call {
	_c.Call.Return(run)
	return _c
}

// IsPacketReceived provides a mock function with given fields: ctx, clientID, sequence
func (_m *MockBridgeClient) IsPacketReceived(ctx context.Context, clientID string, sequence uint64) (bool, error) {
	ret := _m.Called(ctx, clientID, sequence)

	if len(ret) == 0 {
		panic("no return value specified for IsPacketReceived")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) (bool, error)); ok {
		return rf(ctx, clientID, sequence)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64) bool); ok {
		r0 = rf(ctx, clientID, sequence)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint64) error); ok {
		r1 = rf(ctx, clientID, sequence)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_IsPacketReceived_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsPacketReceived'
type MockBridgeClient_IsPacketReceived_Call struct {
	*mock.Call
}

// IsPacketReceived is a helper method to define mock.On call
//   - ctx context.Context
//   - clientID string
//   - sequence uint64
func (_e *MockBridgeClient_Expecter) IsPacketReceived(ctx interface{}, clientID interface{}, sequence interface{}) *MockBridgeClient_IsPacketReceived_Call {
	return &MockBridgeClient_IsPacketReceived_Call{Call: _e.mock.On("IsPacketReceived", ctx, clientID, sequence)}
}

func (_c *MockBridgeClient_IsPacketReceived_Call) Run(run func(ctx context.Context, clientID string, sequence uint64)) *MockBridgeClient_IsPacketReceived_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64))
	})
	return _c
}

func (_c *MockBridgeClient_IsPacketReceived_Call) Return(_a0 bool, _a1 error) *MockBridgeClient_IsPacketReceived_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_IsPacketReceived_Call) RunAndReturn(run func(context.Context, string, uint64) (bool, error)) *MockBridgeClient_IsPacketReceived_Call {
	_c.Call.Return(run)
	return _c
}

// IsTimestampFinalized provides a mock function with given fields: ctx, timestamp, offset
func (_m *MockBridgeClient) IsTimestampFinalized(ctx context.Context, timestamp time.Time, offset *uint64) (bool, error) {
	ret := _m.Called(ctx, timestamp, offset)

	if len(ret) == 0 {
		panic("no return value specified for IsTimestampFinalized")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, *uint64) (bool, error)); ok {
		return rf(ctx, timestamp, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Time, *uint64) bool); ok {
		r0 = rf(ctx, timestamp, offset)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Time, *uint64) error); ok {
		r1 = rf(ctx, timestamp, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_IsTimestampFinalized_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsTimestampFinalized'
type MockBridgeClient_IsTimestampFinalized_Call struct {
	*mock.Call
}

// IsTimestampFinalized is a helper method to define mock.On call
//   - ctx context.Context
//   - timestamp time.Time
//   - offset *uint64
func (_e *MockBridgeClient_Expecter) IsTimestampFinalized(ctx interface{}, timestamp interface{}, offset interface{}) *MockBridgeClient_IsTimestampFinalized_Call {
	return &MockBridgeClient_IsTimestampFinalized_Call{Call: _e.mock.On("IsTimestampFinalized", ctx, timestamp, offset)}
}

func (_c *MockBridgeClient_IsTimestampFinalized_Call) Run(run func(ctx context.Context, timestamp time.Time, offset *uint64)) *MockBridgeClient_IsTimestampFinalized_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time), args[2].(*uint64))
	})
	return _c
}

func (_c *MockBridgeClient_IsTimestampFinalized_Call) Return(_a0 bool, _a1 error) *MockBridgeClient_IsTimestampFinalized_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_IsTimestampFinalized_Call) RunAndReturn(run func(context.Context, time.Time, *uint64) (bool, error)) *MockBridgeClient_IsTimestampFinalized_Call {
	_c.Call.Return(run)
	return _c
}

// IsTxFinalized provides a mock function with given fields: ctx, txHash, offset
func (_m *MockBridgeClient) IsTxFinalized(ctx context.Context, txHash string, offset *uint64) (bool, error) {
	ret := _m.Called(ctx, txHash, offset)

	if len(ret) == 0 {
		panic("no return value specified for IsTxFinalized")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *uint64) (bool, error)); ok {
		return rf(ctx, txHash, offset)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *uint64) bool); ok {
		r0 = rf(ctx, txHash, offset)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *uint64) error); ok {
		r1 = rf(ctx, txHash, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_IsTxFinalized_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsTxFinalized'
type MockBridgeClient_IsTxFinalized_Call struct {
	*mock.Call
}

// IsTxFinalized is a helper method to define mock.On call
//   - ctx context.Context
//   - txHash string
//   - offset *uint64
func (_e *MockBridgeClient_Expecter) IsTxFinalized(ctx interface{}, txHash interface{}, offset interface{}) *MockBridgeClient_IsTxFinalized_Call {
	return &MockBridgeClient_IsTxFinalized_Call{Call: _e.mock.On("IsTxFinalized", ctx, txHash, offset)}
}

func (_c *MockBridgeClient_IsTxFinalized_Call) Run(run func(ctx context.Context, txHash string, offset *uint64)) *MockBridgeClient_IsTxFinalized_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*uint64))
	})
	return _c
}

func (_c *MockBridgeClient_IsTxFinalized_Call) Return(_a0 bool, _a1 error) *MockBridgeClient_IsTxFinalized_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_IsTxFinalized_Call) RunAndReturn(run func(context.Context, string, *uint64) (bool, error)) *MockBridgeClient_IsTxFinalized_Call {
	_c.Call.Return(run)
	return _c
}

// LatestOnChainTimestamp provides a mock function with given fields: ctx
func (_m *MockBridgeClient) LatestOnChainTimestamp(ctx context.Context) (time.Time, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for LatestOnChainTimestamp")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (time.Time, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) time.Time); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_LatestOnChainTimestamp_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LatestOnChainTimestamp'
type MockBridgeClient_LatestOnChainTimestamp_Call struct {
	*mock.Call
}

// LatestOnChainTimestamp is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBridgeClient_Expecter) LatestOnChainTimestamp(ctx interface{}) *MockBridgeClient_LatestOnChainTimestamp_Call {
	return &MockBridgeClient_LatestOnChainTimestamp_Call{Call: _e.mock.On("LatestOnChainTimestamp", ctx)}
}

func (_c *MockBridgeClient_LatestOnChainTimestamp_Call) Run(run func(ctx context.Context)) *MockBridgeClient_LatestOnChainTimestamp_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockBridgeClient_LatestOnChainTimestamp_Call) Return(_a0 time.Time, _a1 error) *MockBridgeClient_LatestOnChainTimestamp_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_LatestOnChainTimestamp_Call) RunAndReturn(run func(context.Context) (time.Time, error)) *MockBridgeClient_LatestOnChainTimestamp_Call {
	_c.Call.Return(run)
	return _c
}

// PacketWriteAckStatus provides a mock function with given fields: ctx, hash, sequence, sourceClientID, destClientID
func (_m *MockBridgeClient) PacketWriteAckStatus(ctx context.Context, hash string, sequence uint64, sourceClientID string, destClientID string) (db.Ibcv2WriteAckStatus, error) {
	ret := _m.Called(ctx, hash, sequence, sourceClientID, destClientID)

	if len(ret) == 0 {
		panic("no return value specified for PacketWriteAckStatus")
	}

	var r0 db.Ibcv2WriteAckStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, string) (db.Ibcv2WriteAckStatus, error)); ok {
		return rf(ctx, hash, sequence, sourceClientID, destClientID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, uint64, string, string) db.Ibcv2WriteAckStatus); ok {
		r0 = rf(ctx, hash, sequence, sourceClientID, destClientID)
	} else {
		r0 = ret.Get(0).(db.Ibcv2WriteAckStatus)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, uint64, string, string) error); ok {
		r1 = rf(ctx, hash, sequence, sourceClientID, destClientID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_PacketWriteAckStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PacketWriteAckStatus'
type MockBridgeClient_PacketWriteAckStatus_Call struct {
	*mock.Call
}

// PacketWriteAckStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - hash string
//   - sequence uint64
//   - sourceClientID string
//   - destClientID string
func (_e *MockBridgeClient_Expecter) PacketWriteAckStatus(ctx interface{}, hash interface{}, sequence interface{}, sourceClientID interface{}, destClientID interface{}) *MockBridgeClient_PacketWriteAckStatus_Call {
	return &MockBridgeClient_PacketWriteAckStatus_Call{Call: _e.mock.On("PacketWriteAckStatus", ctx, hash, sequence, sourceClientID, destClientID)}
}

func (_c *MockBridgeClient_PacketWriteAckStatus_Call) Run(run func(ctx context.Context, hash string, sequence uint64, sourceClientID string, destClientID string)) *MockBridgeClient_PacketWriteAckStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(uint64), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockBridgeClient_PacketWriteAckStatus_Call) Return(_a0 db.Ibcv2WriteAckStatus, _a1 error) *MockBridgeClient_PacketWriteAckStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_PacketWriteAckStatus_Call) RunAndReturn(run func(context.Context, string, uint64, string, string) (db.Ibcv2WriteAckStatus, error)) *MockBridgeClient_PacketWriteAckStatus_Call {
	_c.Call.Return(run)
	return _c
}

// SendPacketsFromTx provides a mock function with given fields: ctx, sourceChainID, txHash
func (_m *MockBridgeClient) SendPacketsFromTx(ctx context.Context, sourceChainID string, txHash string) ([]*ibcv2.PacketInfo, error) {
	ret := _m.Called(ctx, sourceChainID, txHash)

	if len(ret) == 0 {
		panic("no return value specified for SendPacketsFromTx")
	}

	var r0 []*ibcv2.PacketInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]*ibcv2.PacketInfo, error)); ok {
		return rf(ctx, sourceChainID, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*ibcv2.PacketInfo); ok {
		r0 = rf(ctx, sourceChainID, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*ibcv2.PacketInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, sourceChainID, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_SendPacketsFromTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendPacketsFromTx'
type MockBridgeClient_SendPacketsFromTx_Call struct {
	*mock.Call
}

// SendPacketsFromTx is a helper method to define mock.On call
//   - ctx context.Context
//   - sourceChainID string
//   - txHash string
func (_e *MockBridgeClient_Expecter) SendPacketsFromTx(ctx interface{}, sourceChainID interface{}, txHash interface{}) *MockBridgeClient_SendPacketsFromTx_Call {
	return &MockBridgeClient_SendPacketsFromTx_Call{Call: _e.mock.On("SendPacketsFromTx", ctx, sourceChainID, txHash)}
}

func (_c *MockBridgeClient_SendPacketsFromTx_Call) Run(run func(ctx context.Context, sourceChainID string, txHash string)) *MockBridgeClient_SendPacketsFromTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockBridgeClient_SendPacketsFromTx_Call) Return(_a0 []*ibcv2.PacketInfo, _a1 error) *MockBridgeClient_SendPacketsFromTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_SendPacketsFromTx_Call) RunAndReturn(run func(context.Context, string, string) ([]*ibcv2.PacketInfo, error)) *MockBridgeClient_SendPacketsFromTx_Call {
	_c.Call.Return(run)
	return _c
}

// SendTransfer provides a mock function with given fields: ctx, clientID, denom, receiver, amount, memo
func (_m *MockBridgeClient) SendTransfer(ctx context.Context, clientID string, denom string, receiver string, amount *big.Int, memo string) (string, error) {
	ret := _m.Called(ctx, clientID, denom, receiver, amount, memo)

	if len(ret) == 0 {
		panic("no return value specified for SendTransfer")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, *big.Int, string) (string, error)); ok {
		return rf(ctx, clientID, denom, receiver, amount, memo)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, *big.Int, string) string); ok {
		r0 = rf(ctx, clientID, denom, receiver, amount, memo)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, *big.Int, string) error); ok {
		r1 = rf(ctx, clientID, denom, receiver, amount, memo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_SendTransfer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendTransfer'
type MockBridgeClient_SendTransfer_Call struct {
	*mock.Call
}

// SendTransfer is a helper method to define mock.On call
//   - ctx context.Context
//   - clientID string
//   - denom string
//   - receiver string
//   - amount *big.Int
//   - memo string
func (_e *MockBridgeClient_Expecter) SendTransfer(ctx interface{}, clientID interface{}, denom interface{}, receiver interface{}, amount interface{}, memo interface{}) *MockBridgeClient_SendTransfer_Call {
	return &MockBridgeClient_SendTransfer_Call{Call: _e.mock.On("SendTransfer", ctx, clientID, denom, receiver, amount, memo)}
}

func (_c *MockBridgeClient_SendTransfer_Call) Run(run func(ctx context.Context, clientID string, denom string, receiver string, amount *big.Int, memo string)) *MockBridgeClient_SendTransfer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(*big.Int), args[5].(string))
	})
	return _c
}

func (_c *MockBridgeClient_SendTransfer_Call) Return(_a0 string, _a1 error) *MockBridgeClient_SendTransfer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_SendTransfer_Call) RunAndReturn(run func(context.Context, string, string, string, *big.Int, string) (string, error)) *MockBridgeClient_SendTransfer_Call {
	_c.Call.Return(run)
	return _c
}

// ShouldRetryTx provides a mock function with given fields: ctx, txHash, expiry, sentTs
func (_m *MockBridgeClient) ShouldRetryTx(ctx context.Context, txHash string, expiry time.Duration, sentTs time.Time) (bool, error) {
	ret := _m.Called(ctx, txHash, expiry, sentTs)

	if len(ret) == 0 {
		panic("no return value specified for ShouldRetryTx")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, time.Time) (bool, error)); ok {
		return rf(ctx, txHash, expiry, sentTs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, time.Duration, time.Time) bool); ok {
		r0 = rf(ctx, txHash, expiry, sentTs)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, time.Duration, time.Time) error); ok {
		r1 = rf(ctx, txHash, expiry, sentTs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_ShouldRetryTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShouldRetryTx'
type MockBridgeClient_ShouldRetryTx_Call struct {
	*mock.Call
}

// ShouldRetryTx is a helper method to define mock.On call
//   - ctx context.Context
//   - txHash string
//   - expiry time.Duration
//   - sentTs time.Time
func (_e *MockBridgeClient_Expecter) ShouldRetryTx(ctx interface{}, txHash interface{}, expiry interface{}, sentTs interface{}) *MockBridgeClient_ShouldRetryTx_Call {
	return &MockBridgeClient_ShouldRetryTx_Call{Call: _e.mock.On("ShouldRetryTx", ctx, txHash, expiry, sentTs)}
}

func (_c *MockBridgeClient_ShouldRetryTx_Call) Run(run func(ctx context.Context, txHash string, expiry time.Duration, sentTs time.Time)) *MockBridgeClient_ShouldRetryTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(time.Duration), args[3].(time.Time))
	})
	return _c
}

func (_c *MockBridgeClient_ShouldRetryTx_Call) Return(_a0 bool, _a1 error) *MockBridgeClient_ShouldRetryTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_ShouldRetryTx_Call) RunAndReturn(run func(context.Context, string, time.Duration, time.Time) (bool, error)) *MockBridgeClient_ShouldRetryTx_Call {
	_c.Call.Return(run)
	return _c
}

// SignerGasTokenBalance provides a mock function with given fields: ctx
func (_m *MockBridgeClient) SignerGasTokenBalance(ctx context.Context) (*big.Int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SignerGasTokenBalance")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*big.Int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *big.Int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_SignerGasTokenBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SignerGasTokenBalance'
type MockBridgeClient_SignerGasTokenBalance_Call struct {
	*mock.Call
}

// SignerGasTokenBalance is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBridgeClient_Expecter) SignerGasTokenBalance(ctx interface{}) *MockBridgeClient_SignerGasTokenBalance_Call {
	return &MockBridgeClient_SignerGasTokenBalance_Call{Call: _e.mock.On("SignerGasTokenBalance", ctx)}
}

func (_c *MockBridgeClient_SignerGasTokenBalance_Call) Run(run func(ctx context.Context)) *MockBridgeClient_SignerGasTokenBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockBridgeClient_SignerGasTokenBalance_Call) Return(_a0 *big.Int, _a1 error) *MockBridgeClient_SignerGasTokenBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_SignerGasTokenBalance_Call) RunAndReturn(run func(context.Context) (*big.Int, error)) *MockBridgeClient_SignerGasTokenBalance_Call {
	_c.Call.Return(run)
	return _c
}

// TimestampAtHeight provides a mock function with given fields: ctx, height
func (_m *MockBridgeClient) TimestampAtHeight(ctx context.Context, height uint64) (time.Time, error) {
	ret := _m.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for TimestampAtHeight")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) (time.Time, error)); ok {
		return rf(ctx, height)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64) time.Time); ok {
		r0 = rf(ctx, height)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_TimestampAtHeight_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TimestampAtHeight'
type MockBridgeClient_TimestampAtHeight_Call struct {
	*mock.Call
}

// TimestampAtHeight is a helper method to define mock.On call
//   - ctx context.Context
//   - height uint64
func (_e *MockBridgeClient_Expecter) TimestampAtHeight(ctx interface{}, height interface{}) *MockBridgeClient_TimestampAtHeight_Call {
	return &MockBridgeClient_TimestampAtHeight_Call{Call: _e.mock.On("TimestampAtHeight", ctx, height)}
}

func (_c *MockBridgeClient_TimestampAtHeight_Call) Run(run func(ctx context.Context, height uint64)) *MockBridgeClient_TimestampAtHeight_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint64))
	})
	return _c
}

func (_c *MockBridgeClient_TimestampAtHeight_Call) Return(_a0 time.Time, _a1 error) *MockBridgeClient_TimestampAtHeight_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_TimestampAtHeight_Call) RunAndReturn(run func(context.Context, uint64) (time.Time, error)) *MockBridgeClient_TimestampAtHeight_Call {
	_c.Call.Return(run)
	return _c
}

// TxFee provides a mock function with given fields: ctx, txHash
func (_m *MockBridgeClient) TxFee(ctx context.Context, txHash string) (*big.Int, error) {
	ret := _m.Called(ctx, txHash)

	if len(ret) == 0 {
		panic("no return value specified for TxFee")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*big.Int, error)); ok {
		return rf(ctx, txHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *big.Int); ok {
		r0 = rf(ctx, txHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, txHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBridgeClient_TxFee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxFee'
type MockBridgeClient_TxFee_Call struct {
	*mock.Call
}

// TxFee is a helper method to define mock.On call
//   - ctx context.Context
//   - txHash string
func (_e *MockBridgeClient_Expecter) TxFee(ctx interface{}, txHash interface{}) *MockBridgeClient_TxFee_Call {
	return &MockBridgeClient_TxFee_Call{Call: _e.mock.On("TxFee", ctx, txHash)}
}

func (_c *MockBridgeClient_TxFee_Call) Run(run func(ctx context.Context, txHash string)) *MockBridgeClient_TxFee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockBridgeClient_TxFee_Call) Return(_a0 *big.Int, _a1 error) *MockBridgeClient_TxFee_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBridgeClient_TxFee_Call) RunAndReturn(run func(context.Context, string) (*big.Int, error)) *MockBridgeClient_TxFee_Call {
	_c.Call.Return(run)
	return _c
}

// WaitForChain provides a mock function with given fields: ctx
func (_m *MockBridgeClient) WaitForChain(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for WaitForChain")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBridgeClient_WaitForChain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitForChain'
type MockBridgeClient_WaitForChain_Call struct {
	*mock.Call
}

// WaitForChain is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBridgeClient_Expecter) WaitForChain(ctx interface{}) *MockBridgeClient_WaitForChain_Call {
	return &MockBridgeClient_WaitForChain_Call{Call: _e.mock.On("WaitForChain", ctx)}
}

func (_c *MockBridgeClient_WaitForChain_Call) Run(run func(ctx context.Context)) *MockBridgeClient_WaitForChain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockBridgeClient_WaitForChain_Call) Return(_a0 error) *MockBridgeClient_WaitForChain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBridgeClient_WaitForChain_Call) RunAndReturn(run func(context.Context) error) *MockBridgeClient_WaitForChain_Call {
	_c.Call.Return(run)
	return _c
}

// WaitForTx provides a mock function with given fields: ctx, hash
func (_m *MockBridgeClient) WaitForTx(ctx context.Context, hash string) error {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for WaitForTx")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockBridgeClient_WaitForTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WaitForTx'
type MockBridgeClient_WaitForTx_Call struct {
	*mock.Call
}

// WaitForTx is a helper method to define mock.On call
//   - ctx context.Context
//   - hash string
func (_e *MockBridgeClient_Expecter) WaitForTx(ctx interface{}, hash interface{}) *MockBridgeClient_WaitForTx_Call {
	return &MockBridgeClient_WaitForTx_Call{Call: _e.mock.On("WaitForTx", ctx, hash)}
}

func (_c *MockBridgeClient_WaitForTx_Call) Run(run func(ctx context.Context, hash string)) *MockBridgeClient_WaitForTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockBridgeClient_WaitForTx_Call) Return(_a0 error) *MockBridgeClient_WaitForTx_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBridgeClient_WaitForTx_Call) RunAndReturn(run func(context.Context, string) error) *MockBridgeClient_WaitForTx_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBridgeClient creates a new instance of MockBridgeClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBridgeClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBridgeClient {
	mock := &MockBridgeClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
