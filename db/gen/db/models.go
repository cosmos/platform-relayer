// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BridgeType string

const (
	BridgeTypeIbcv2 BridgeType = "ibcv2"
)

func (e *BridgeType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BridgeType(s)
	case string:
		*e = BridgeType(s)
	default:
		return fmt.Errorf("unsupported scan type for BridgeType: %T", src)
	}
	return nil
}

type NullBridgeType struct {
	BridgeType BridgeType
	Valid      bool // Valid is true if BridgeType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBridgeType) Scan(value interface{}) error {
	if value == nil {
		ns.BridgeType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BridgeType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBridgeType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BridgeType), nil
}

type Ibcv2RelayStatus string

const (
	Ibcv2RelayStatusPENDING                     Ibcv2RelayStatus = "PENDING"
	Ibcv2RelayStatusCHECKRECVPACKETDELIVERY     Ibcv2RelayStatus = "CHECK_RECV_PACKET_DELIVERY"
	Ibcv2RelayStatusGETRECVPACKET               Ibcv2RelayStatus = "GET_RECV_PACKET"
	Ibcv2RelayStatusDELIVERRECVPACKET           Ibcv2RelayStatus = "DELIVER_RECV_PACKET"
	Ibcv2RelayStatusWAITFORWRITEACK             Ibcv2RelayStatus = "WAIT_FOR_WRITE_ACK"
	Ibcv2RelayStatusCHECKACKPACKETDELIVERY      Ibcv2RelayStatus = "CHECK_ACK_PACKET_DELIVERY"
	Ibcv2RelayStatusGETACKPACKET                Ibcv2RelayStatus = "GET_ACK_PACKET"
	Ibcv2RelayStatusDELIVERACKPACKET            Ibcv2RelayStatus = "DELIVER_ACK_PACKET"
	Ibcv2RelayStatusCHECKTIMEOUTPACKETDELIVERY  Ibcv2RelayStatus = "CHECK_TIMEOUT_PACKET_DELIVERY"
	Ibcv2RelayStatusGETTIMEOUTPACKET            Ibcv2RelayStatus = "GET_TIMEOUT_PACKET"
	Ibcv2RelayStatusDELIVERTIMEOUTPACKET        Ibcv2RelayStatus = "DELIVER_TIMEOUT_PACKET"
	Ibcv2RelayStatusCOMPLETEWITHACK             Ibcv2RelayStatus = "COMPLETE_WITH_ACK"
	Ibcv2RelayStatusCOMPLETEWITHTIMEOUT         Ibcv2RelayStatus = "COMPLETE_WITH_TIMEOUT"
	Ibcv2RelayStatusFAILED                      Ibcv2RelayStatus = "FAILED"
	Ibcv2RelayStatusAWAITINGSENDFINALITY        Ibcv2RelayStatus = "AWAITING_SEND_FINALITY"
	Ibcv2RelayStatusAWAITINGWRITEACKFINALITY    Ibcv2RelayStatus = "AWAITING_WRITE_ACK_FINALITY"
	Ibcv2RelayStatusCOMPLETEWITHWRITEACKSUCCESS Ibcv2RelayStatus = "COMPLETE_WITH_WRITE_ACK_SUCCESS"
	Ibcv2RelayStatusAWAITINGTIMEOUTFINALITY     Ibcv2RelayStatus = "AWAITING_TIMEOUT_FINALITY"
	Ibcv2RelayStatusCOMPLETEWITHWRITEACKERROR   Ibcv2RelayStatus = "COMPLETE_WITH_WRITE_ACK_ERROR"
	Ibcv2RelayStatusCALCULATINGRECVTXGASCOST    Ibcv2RelayStatus = "CALCULATING_RECV_TX_GAS_COST"
	Ibcv2RelayStatusCALCULATINGACKTXGASCOST     Ibcv2RelayStatus = "CALCULATING_ACK_TX_GAS_COST"
	Ibcv2RelayStatusCALCULATINGTIMEOUTTXGASCOST Ibcv2RelayStatus = "CALCULATING_TIMEOUT_TX_GAS_COST"
)

func (e *Ibcv2RelayStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Ibcv2RelayStatus(s)
	case string:
		*e = Ibcv2RelayStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for Ibcv2RelayStatus: %T", src)
	}
	return nil
}

type NullIbcv2RelayStatus struct {
	Ibcv2RelayStatus Ibcv2RelayStatus
	Valid            bool // Valid is true if Ibcv2RelayStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIbcv2RelayStatus) Scan(value interface{}) error {
	if value == nil {
		ns.Ibcv2RelayStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Ibcv2RelayStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIbcv2RelayStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Ibcv2RelayStatus), nil
}

type Ibcv2WriteAckStatus string

const (
	Ibcv2WriteAckStatusSUCCESS Ibcv2WriteAckStatus = "SUCCESS"
	Ibcv2WriteAckStatusERROR   Ibcv2WriteAckStatus = "ERROR"
	Ibcv2WriteAckStatusUNKNOWN Ibcv2WriteAckStatus = "UNKNOWN"
)

func (e *Ibcv2WriteAckStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Ibcv2WriteAckStatus(s)
	case string:
		*e = Ibcv2WriteAckStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for Ibcv2WriteAckStatus: %T", src)
	}
	return nil
}

type NullIbcv2WriteAckStatus struct {
	Ibcv2WriteAckStatus Ibcv2WriteAckStatus
	Valid               bool // Valid is true if Ibcv2WriteAckStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIbcv2WriteAckStatus) Scan(value interface{}) error {
	if value == nil {
		ns.Ibcv2WriteAckStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Ibcv2WriteAckStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIbcv2WriteAckStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Ibcv2WriteAckStatus), nil
}

type Ibcv2RelaySubmission struct {
	ID            int32
	SourceChainID string
	SourceTxHash  string
	CreatedAt     pgtype.Timestamptz
}

type Ibcv2Transfer struct {
	ID                        int32
	CreatedAt                 pgtype.Timestamp
	UpdatedAt                 pgtype.Timestamp
	Status                    Ibcv2RelayStatus
	StatusText                pgtype.Text
	SourceChainID             string
	DestinationChainID        string
	SourceTxHash              string
	SourceTxTime              pgtype.Timestamp
	PacketSequenceNumber      int32
	PacketSourceClientID      string
	PacketDestinationClientID string
	PacketTimeoutTimestamp    pgtype.Timestamp
	RecvTxHash                pgtype.Text
	RecvTxTime                pgtype.Timestamp
	WriteAckTxHash            pgtype.Text
	WriteAckTxTime            pgtype.Timestamp
	AckTxHash                 pgtype.Text
	AckTxTime                 pgtype.Timestamp
	TimeoutTxHash             pgtype.Text
	TimeoutTxTime             pgtype.Timestamp
	WriteAckStatus            NullIbcv2WriteAckStatus
	RecvTxGasCostUsd          pgtype.Numeric
	AckTxGasCostUsd           pgtype.Numeric
	TimeoutTxGasCostUsd       pgtype.Numeric
	RecvTxRelayerAddress      pgtype.Text
	AckTxRelayerAddress       pgtype.Text
	TimeoutTxRelayerAddress   pgtype.Text
	SourceTxFinalizedTime     pgtype.Timestamp
	WriteAckTxFinalizedTime   pgtype.Timestamp
}

type RawTx struct {
	ID            int32
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	CctpMessageID int32
	TxHash        string
	RawTx         string
	ChainID       pgtype.Text
	Nonce         pgtype.Text
}
