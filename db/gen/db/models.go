// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type BridgeType string

const (
	BridgeTypeEureka BridgeType = "eureka"
)

func (e *BridgeType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = BridgeType(s)
	case string:
		*e = BridgeType(s)
	default:
		return fmt.Errorf("unsupported scan type for BridgeType: %T", src)
	}
	return nil
}

type NullBridgeType struct {
	BridgeType BridgeType
	Valid      bool // Valid is true if BridgeType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullBridgeType) Scan(value interface{}) error {
	if value == nil {
		ns.BridgeType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.BridgeType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullBridgeType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.BridgeType), nil
}

type EurekaRelayStatus string

const (
	EurekaRelayStatusPENDING                     EurekaRelayStatus = "PENDING"
	EurekaRelayStatusCHECKRECVPACKETDELIVERY     EurekaRelayStatus = "CHECK_RECV_PACKET_DELIVERY"
	EurekaRelayStatusGETRECVPACKET               EurekaRelayStatus = "GET_RECV_PACKET"
	EurekaRelayStatusDELIVERRECVPACKET           EurekaRelayStatus = "DELIVER_RECV_PACKET"
	EurekaRelayStatusWAITFORWRITEACK             EurekaRelayStatus = "WAIT_FOR_WRITE_ACK"
	EurekaRelayStatusCHECKACKPACKETDELIVERY      EurekaRelayStatus = "CHECK_ACK_PACKET_DELIVERY"
	EurekaRelayStatusGETACKPACKET                EurekaRelayStatus = "GET_ACK_PACKET"
	EurekaRelayStatusDELIVERACKPACKET            EurekaRelayStatus = "DELIVER_ACK_PACKET"
	EurekaRelayStatusCHECKTIMEOUTPACKETDELIVERY  EurekaRelayStatus = "CHECK_TIMEOUT_PACKET_DELIVERY"
	EurekaRelayStatusGETTIMEOUTPACKET            EurekaRelayStatus = "GET_TIMEOUT_PACKET"
	EurekaRelayStatusDELIVERTIMEOUTPACKET        EurekaRelayStatus = "DELIVER_TIMEOUT_PACKET"
	EurekaRelayStatusCOMPLETEWITHACK             EurekaRelayStatus = "COMPLETE_WITH_ACK"
	EurekaRelayStatusCOMPLETEWITHTIMEOUT         EurekaRelayStatus = "COMPLETE_WITH_TIMEOUT"
	EurekaRelayStatusFAILED                      EurekaRelayStatus = "FAILED"
	EurekaRelayStatusAWAITINGSENDFINALITY        EurekaRelayStatus = "AWAITING_SEND_FINALITY"
	EurekaRelayStatusAWAITINGWRITEACKFINALITY    EurekaRelayStatus = "AWAITING_WRITE_ACK_FINALITY"
	EurekaRelayStatusCOMPLETEWITHWRITEACKSUCCESS EurekaRelayStatus = "COMPLETE_WITH_WRITE_ACK_SUCCESS"
	EurekaRelayStatusAWAITINGTIMEOUTFINALITY     EurekaRelayStatus = "AWAITING_TIMEOUT_FINALITY"
	EurekaRelayStatusCOMPLETEWITHWRITEACKERROR   EurekaRelayStatus = "COMPLETE_WITH_WRITE_ACK_ERROR"
	EurekaRelayStatusCALCULATINGRECVTXGASCOST    EurekaRelayStatus = "CALCULATING_RECV_TX_GAS_COST"
	EurekaRelayStatusCALCULATINGACKTXGASCOST     EurekaRelayStatus = "CALCULATING_ACK_TX_GAS_COST"
	EurekaRelayStatusCALCULATINGTIMEOUTTXGASCOST EurekaRelayStatus = "CALCULATING_TIMEOUT_TX_GAS_COST"
)

func (e *EurekaRelayStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EurekaRelayStatus(s)
	case string:
		*e = EurekaRelayStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EurekaRelayStatus: %T", src)
	}
	return nil
}

type NullEurekaRelayStatus struct {
	EurekaRelayStatus EurekaRelayStatus
	Valid             bool // Valid is true if EurekaRelayStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEurekaRelayStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EurekaRelayStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EurekaRelayStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEurekaRelayStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EurekaRelayStatus), nil
}

type EurekaWriteAckStatus string

const (
	EurekaWriteAckStatusSUCCESS EurekaWriteAckStatus = "SUCCESS"
	EurekaWriteAckStatusERROR   EurekaWriteAckStatus = "ERROR"
	EurekaWriteAckStatusUNKNOWN EurekaWriteAckStatus = "UNKNOWN"
)

func (e *EurekaWriteAckStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EurekaWriteAckStatus(s)
	case string:
		*e = EurekaWriteAckStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EurekaWriteAckStatus: %T", src)
	}
	return nil
}

type NullEurekaWriteAckStatus struct {
	EurekaWriteAckStatus EurekaWriteAckStatus
	Valid                bool // Valid is true if EurekaWriteAckStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEurekaWriteAckStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EurekaWriteAckStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EurekaWriteAckStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEurekaWriteAckStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EurekaWriteAckStatus), nil
}

type EurekaRelaySubmission struct {
	ID            int32
	SourceChainID string
	SourceTxHash  string
	CreatedAt     pgtype.Timestamptz
}

type EurekaTransfer struct {
	ID                        int32
	CreatedAt                 pgtype.Timestamp
	UpdatedAt                 pgtype.Timestamp
	Status                    EurekaRelayStatus
	StatusText                pgtype.Text
	SourceChainID             string
	DestinationChainID        string
	SourceTxHash              string
	SourceTxTime              pgtype.Timestamp
	PacketSequenceNumber      int32
	PacketSourceClientID      string
	PacketDestinationClientID string
	PacketTimeoutTimestamp    pgtype.Timestamp
	RecvTxHash                pgtype.Text
	RecvTxTime                pgtype.Timestamp
	WriteAckTxHash            pgtype.Text
	WriteAckTxTime            pgtype.Timestamp
	AckTxHash                 pgtype.Text
	AckTxTime                 pgtype.Timestamp
	TimeoutTxHash             pgtype.Text
	TimeoutTxTime             pgtype.Timestamp
	WriteAckStatus            NullEurekaWriteAckStatus
	RecvTxGasCostUsd          pgtype.Numeric
	AckTxGasCostUsd           pgtype.Numeric
	TimeoutTxGasCostUsd       pgtype.Numeric
	RecvTxRelayerAddress      pgtype.Text
	AckTxRelayerAddress       pgtype.Text
	TimeoutTxRelayerAddress   pgtype.Text
	SourceTxFinalizedTime     pgtype.Timestamp
	WriteAckTxFinalizedTime   pgtype.Timestamp
}

type RawTx struct {
	ID            int32
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	CctpMessageID int32
	TxHash        string
	RawTx         string
	ChainID       pgtype.Text
	Nonce         pgtype.Text
}
