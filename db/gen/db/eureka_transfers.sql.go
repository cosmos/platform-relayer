// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: eureka_transfers.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearAckTx = `-- name: ClearAckTx :exec
UPDATE eureka_transfers 
set ack_tx_hash=null, ack_tx_time=null
WHERE source_chain_id=$1 AND packet_source_client_id=$2 AND packet_sequence_number=$3
`

type ClearAckTxParams struct {
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) ClearAckTx(ctx context.Context, arg ClearAckTxParams) error {
	_, err := q.db.Exec(ctx, clearAckTx, arg.SourceChainID, arg.PacketSourceClientID, arg.PacketSequenceNumber)
	return err
}

const clearRecvTx = `-- name: ClearRecvTx :exec
UPDATE eureka_transfers 
set recv_tx_hash=null, recv_tx_time=null
WHERE source_chain_id=$1 AND packet_source_client_id=$2 AND packet_sequence_number=$3
`

type ClearRecvTxParams struct {
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) ClearRecvTx(ctx context.Context, arg ClearRecvTxParams) error {
	_, err := q.db.Exec(ctx, clearRecvTx, arg.SourceChainID, arg.PacketSourceClientID, arg.PacketSequenceNumber)
	return err
}

const clearTimeoutTx = `-- name: ClearTimeoutTx :exec
UPDATE eureka_transfers 
set timeout_tx_hash=null, timeout_tx_time=null
WHERE source_chain_id=$1 AND packet_source_client_id=$2 AND packet_sequence_number=$3
`

type ClearTimeoutTxParams struct {
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) ClearTimeoutTx(ctx context.Context, arg ClearTimeoutTxParams) error {
	_, err := q.db.Exec(ctx, clearTimeoutTx, arg.SourceChainID, arg.PacketSourceClientID, arg.PacketSequenceNumber)
	return err
}

const getRelaySubmission = `-- name: GetRelaySubmission :one
SELECT id, source_chain_id, source_tx_hash, created_at FROM eureka_relay_submissions
WHERE source_chain_id = $1 AND source_tx_hash = $2
`

type GetRelaySubmissionParams struct {
	SourceChainID string
	SourceTxHash  string
}

func (q *Queries) GetRelaySubmission(ctx context.Context, arg GetRelaySubmissionParams) (EurekaRelaySubmission, error) {
	row := q.db.QueryRow(ctx, getRelaySubmission, arg.SourceChainID, arg.SourceTxHash)
	var i EurekaRelaySubmission
	err := row.Scan(
		&i.ID,
		&i.SourceChainID,
		&i.SourceTxHash,
		&i.CreatedAt,
	)
	return i, err
}

const getTransfersBySourceTx = `-- name: GetTransfersBySourceTx :many
SELECT id, created_at, updated_at, status, status_text, source_chain_id, destination_chain_id, source_tx_hash, source_tx_time, packet_sequence_number, packet_source_client_id, packet_destination_client_id, packet_timeout_timestamp, recv_tx_hash, recv_tx_time, write_ack_tx_hash, write_ack_tx_time, ack_tx_hash, ack_tx_time, timeout_tx_hash, timeout_tx_time, write_ack_status, recv_tx_gas_cost_usd, ack_tx_gas_cost_usd, timeout_tx_gas_cost_usd, recv_tx_relayer_address, ack_tx_relayer_address, timeout_tx_relayer_address, source_tx_finalized_time, write_ack_tx_finalized_time FROM eureka_transfers
WHERE source_chain_id = $1 AND source_tx_hash = $2
`

type GetTransfersBySourceTxParams struct {
	SourceChainID string
	SourceTxHash  string
}

func (q *Queries) GetTransfersBySourceTx(ctx context.Context, arg GetTransfersBySourceTxParams) ([]EurekaTransfer, error) {
	rows, err := q.db.Query(ctx, getTransfersBySourceTx, arg.SourceChainID, arg.SourceTxHash)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EurekaTransfer
	for rows.Next() {
		var i EurekaTransfer
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.StatusText,
			&i.SourceChainID,
			&i.DestinationChainID,
			&i.SourceTxHash,
			&i.SourceTxTime,
			&i.PacketSequenceNumber,
			&i.PacketSourceClientID,
			&i.PacketDestinationClientID,
			&i.PacketTimeoutTimestamp,
			&i.RecvTxHash,
			&i.RecvTxTime,
			&i.WriteAckTxHash,
			&i.WriteAckTxTime,
			&i.AckTxHash,
			&i.AckTxTime,
			&i.TimeoutTxHash,
			&i.TimeoutTxTime,
			&i.WriteAckStatus,
			&i.RecvTxGasCostUsd,
			&i.AckTxGasCostUsd,
			&i.TimeoutTxGasCostUsd,
			&i.RecvTxRelayerAddress,
			&i.AckTxRelayerAddress,
			&i.TimeoutTxRelayerAddress,
			&i.SourceTxFinalizedTime,
			&i.WriteAckTxFinalizedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnfinishedEurekaTransfers = `-- name: GetUnfinishedEurekaTransfers :many
SELECT id, created_at, updated_at, status, status_text, source_chain_id, destination_chain_id, source_tx_hash, source_tx_time, packet_sequence_number, packet_source_client_id, packet_destination_client_id, packet_timeout_timestamp, recv_tx_hash, recv_tx_time, write_ack_tx_hash, write_ack_tx_time, ack_tx_hash, ack_tx_time, timeout_tx_hash, timeout_tx_time, write_ack_status, recv_tx_gas_cost_usd, ack_tx_gas_cost_usd, timeout_tx_gas_cost_usd, recv_tx_relayer_address, ack_tx_relayer_address, timeout_tx_relayer_address, source_tx_finalized_time, write_ack_tx_finalized_time FROM eureka_transfers
WHERE status!='COMPLETE_WITH_ACK' AND status!='COMPLETE_WITH_TIMEOUT' AND status!='FAILED' and status!='COMPLETE_WITH_WRITE_ACK_SUCCESS' and status!='COMPLETE_WITH_WRITE_ACK_ERROR'
`

func (q *Queries) GetUnfinishedEurekaTransfers(ctx context.Context) ([]EurekaTransfer, error) {
	rows, err := q.db.Query(ctx, getUnfinishedEurekaTransfers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EurekaTransfer
	for rows.Next() {
		var i EurekaTransfer
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.StatusText,
			&i.SourceChainID,
			&i.DestinationChainID,
			&i.SourceTxHash,
			&i.SourceTxTime,
			&i.PacketSequenceNumber,
			&i.PacketSourceClientID,
			&i.PacketDestinationClientID,
			&i.PacketTimeoutTimestamp,
			&i.RecvTxHash,
			&i.RecvTxTime,
			&i.WriteAckTxHash,
			&i.WriteAckTxTime,
			&i.AckTxHash,
			&i.AckTxTime,
			&i.TimeoutTxHash,
			&i.TimeoutTxTime,
			&i.WriteAckStatus,
			&i.RecvTxGasCostUsd,
			&i.AckTxGasCostUsd,
			&i.TimeoutTxGasCostUsd,
			&i.RecvTxRelayerAddress,
			&i.AckTxRelayerAddress,
			&i.TimeoutTxRelayerAddress,
			&i.SourceTxFinalizedTime,
			&i.WriteAckTxFinalizedTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEurekaTransfer = `-- name: InsertEurekaTransfer :exec
INSERT INTO eureka_transfers (
    source_chain_id,
    destination_chain_id,
    source_tx_hash,
    source_tx_time,
    packet_sequence_number,
    packet_source_client_id,
    packet_destination_client_id,
    packet_timeout_timestamp
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type InsertEurekaTransferParams struct {
	SourceChainID             string
	DestinationChainID        string
	SourceTxHash              string
	SourceTxTime              pgtype.Timestamp
	PacketSequenceNumber      int32
	PacketSourceClientID      string
	PacketDestinationClientID string
	PacketTimeoutTimestamp    pgtype.Timestamp
}

func (q *Queries) InsertEurekaTransfer(ctx context.Context, arg InsertEurekaTransferParams) error {
	_, err := q.db.Exec(ctx, insertEurekaTransfer,
		arg.SourceChainID,
		arg.DestinationChainID,
		arg.SourceTxHash,
		arg.SourceTxTime,
		arg.PacketSequenceNumber,
		arg.PacketSourceClientID,
		arg.PacketDestinationClientID,
		arg.PacketTimeoutTimestamp,
	)
	return err
}

const insertRelaySubmission = `-- name: InsertRelaySubmission :exec
INSERT INTO eureka_relay_submissions (source_chain_id, source_tx_hash)
VALUES ($1, $2)
ON CONFLICT (source_chain_id, source_tx_hash) DO NOTHING
`

type InsertRelaySubmissionParams struct {
	SourceChainID string
	SourceTxHash  string
}

func (q *Queries) InsertRelaySubmission(ctx context.Context, arg InsertRelaySubmissionParams) error {
	_, err := q.db.Exec(ctx, insertRelaySubmission, arg.SourceChainID, arg.SourceTxHash)
	return err
}

const updateTransferAckTx = `-- name: UpdateTransferAckTx :exec
UPDATE eureka_transfers
SET updated_at=NOW(), ack_tx_hash=$1, ack_tx_time=$2, ack_tx_relayer_address=$3
WHERE source_chain_id=$4 AND packet_source_client_id=$5 AND packet_sequence_number=$6
`

type UpdateTransferAckTxParams struct {
	AckTxHash            pgtype.Text
	AckTxTime            pgtype.Timestamp
	AckTxRelayerAddress  pgtype.Text
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) UpdateTransferAckTx(ctx context.Context, arg UpdateTransferAckTxParams) error {
	_, err := q.db.Exec(ctx, updateTransferAckTx,
		arg.AckTxHash,
		arg.AckTxTime,
		arg.AckTxRelayerAddress,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}

const updateTransferAckTxGasCostUSD = `-- name: UpdateTransferAckTxGasCostUSD :exec
UPDATE eureka_transfers
SET updated_at=NOW(), ack_tx_gas_cost_usd=$1
WHERE source_chain_id=$2 AND packet_source_client_id=$3 AND packet_sequence_number=$4
`

type UpdateTransferAckTxGasCostUSDParams struct {
	AckTxGasCostUsd      pgtype.Numeric
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) UpdateTransferAckTxGasCostUSD(ctx context.Context, arg UpdateTransferAckTxGasCostUSDParams) error {
	_, err := q.db.Exec(ctx, updateTransferAckTxGasCostUSD,
		arg.AckTxGasCostUsd,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}

const updateTransferRecvTx = `-- name: UpdateTransferRecvTx :exec
UPDATE eureka_transfers
SET updated_at=NOW(), recv_tx_hash=$1, recv_tx_time=$2, recv_tx_relayer_address=$3
WHERE source_chain_id=$4 AND packet_source_client_id=$5 AND packet_sequence_number=$6
`

type UpdateTransferRecvTxParams struct {
	RecvTxHash           pgtype.Text
	RecvTxTime           pgtype.Timestamp
	RecvTxRelayerAddress pgtype.Text
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) UpdateTransferRecvTx(ctx context.Context, arg UpdateTransferRecvTxParams) error {
	_, err := q.db.Exec(ctx, updateTransferRecvTx,
		arg.RecvTxHash,
		arg.RecvTxTime,
		arg.RecvTxRelayerAddress,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}

const updateTransferRecvTxGasCostUSD = `-- name: UpdateTransferRecvTxGasCostUSD :exec
UPDATE eureka_transfers
SET updated_at=NOW(), recv_tx_gas_cost_usd=$1
WHERE source_chain_id=$2 AND packet_source_client_id=$3 AND packet_sequence_number=$4
`

type UpdateTransferRecvTxGasCostUSDParams struct {
	RecvTxGasCostUsd     pgtype.Numeric
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) UpdateTransferRecvTxGasCostUSD(ctx context.Context, arg UpdateTransferRecvTxGasCostUSDParams) error {
	_, err := q.db.Exec(ctx, updateTransferRecvTxGasCostUSD,
		arg.RecvTxGasCostUsd,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}

const updateTransferSourceTxFinalizedTime = `-- name: UpdateTransferSourceTxFinalizedTime :exec
UPDATE eureka_transfers
SET updated_at=NOW(), source_tx_finalized_time=$1
WHERE source_chain_id=$2 AND packet_source_client_id=$3 AND packet_sequence_number=$4
`

type UpdateTransferSourceTxFinalizedTimeParams struct {
	SourceTxFinalizedTime pgtype.Timestamp
	SourceChainID         string
	PacketSourceClientID  string
	PacketSequenceNumber  int32
}

func (q *Queries) UpdateTransferSourceTxFinalizedTime(ctx context.Context, arg UpdateTransferSourceTxFinalizedTimeParams) error {
	_, err := q.db.Exec(ctx, updateTransferSourceTxFinalizedTime,
		arg.SourceTxFinalizedTime,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}

const updateTransferState = `-- name: UpdateTransferState :exec
UPDATE eureka_transfers
SET updated_at=NOW(), status=$1
WHERE source_chain_id=$2 AND packet_source_client_id=$3 AND packet_sequence_number=$4
`

type UpdateTransferStateParams struct {
	Status               EurekaRelayStatus
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) UpdateTransferState(ctx context.Context, arg UpdateTransferStateParams) error {
	_, err := q.db.Exec(ctx, updateTransferState,
		arg.Status,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}

const updateTransferTimeoutTx = `-- name: UpdateTransferTimeoutTx :exec
UPDATE eureka_transfers
SET updated_at=NOW(), timeout_tx_hash=$1, timeout_tx_time=$2, timeout_tx_relayer_address=$3
WHERE source_chain_id=$4 AND packet_source_client_id=$5 AND packet_sequence_number=$6
`

type UpdateTransferTimeoutTxParams struct {
	TimeoutTxHash           pgtype.Text
	TimeoutTxTime           pgtype.Timestamp
	TimeoutTxRelayerAddress pgtype.Text
	SourceChainID           string
	PacketSourceClientID    string
	PacketSequenceNumber    int32
}

func (q *Queries) UpdateTransferTimeoutTx(ctx context.Context, arg UpdateTransferTimeoutTxParams) error {
	_, err := q.db.Exec(ctx, updateTransferTimeoutTx,
		arg.TimeoutTxHash,
		arg.TimeoutTxTime,
		arg.TimeoutTxRelayerAddress,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}

const updateTransferTimeoutTxGasCostUSD = `-- name: UpdateTransferTimeoutTxGasCostUSD :exec
UPDATE eureka_transfers
SET updated_at=NOW(), timeout_tx_gas_cost_usd=$1
WHERE source_chain_id=$2 AND packet_source_client_id=$3 AND packet_sequence_number=$4
`

type UpdateTransferTimeoutTxGasCostUSDParams struct {
	TimeoutTxGasCostUsd  pgtype.Numeric
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) UpdateTransferTimeoutTxGasCostUSD(ctx context.Context, arg UpdateTransferTimeoutTxGasCostUSDParams) error {
	_, err := q.db.Exec(ctx, updateTransferTimeoutTxGasCostUSD,
		arg.TimeoutTxGasCostUsd,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}

const updateTransferWriteAckTx = `-- name: UpdateTransferWriteAckTx :exec
UPDATE eureka_transfers
SET updated_at=NOW(), write_ack_tx_hash=$1, write_ack_tx_time=$2, write_ack_status=$3
WHERE source_chain_id=$4 AND packet_source_client_id=$5 AND packet_sequence_number=$6
`

type UpdateTransferWriteAckTxParams struct {
	WriteAckTxHash       pgtype.Text
	WriteAckTxTime       pgtype.Timestamp
	WriteAckStatus       NullEurekaWriteAckStatus
	SourceChainID        string
	PacketSourceClientID string
	PacketSequenceNumber int32
}

func (q *Queries) UpdateTransferWriteAckTx(ctx context.Context, arg UpdateTransferWriteAckTxParams) error {
	_, err := q.db.Exec(ctx, updateTransferWriteAckTx,
		arg.WriteAckTxHash,
		arg.WriteAckTxTime,
		arg.WriteAckStatus,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}

const updateTransferWriteAckTxFinalizedTime = `-- name: UpdateTransferWriteAckTxFinalizedTime :exec
UPDATE eureka_transfers
SET updated_at=NOW(), write_ack_tx_finalized_time=$1
WHERE source_chain_id=$2 AND packet_source_client_id=$3 AND packet_sequence_number=$4
`

type UpdateTransferWriteAckTxFinalizedTimeParams struct {
	WriteAckTxFinalizedTime pgtype.Timestamp
	SourceChainID           string
	PacketSourceClientID    string
	PacketSequenceNumber    int32
}

func (q *Queries) UpdateTransferWriteAckTxFinalizedTime(ctx context.Context, arg UpdateTransferWriteAckTxFinalizedTimeParams) error {
	_, err := q.db.Exec(ctx, updateTransferWriteAckTxFinalizedTime,
		arg.WriteAckTxFinalizedTime,
		arg.SourceChainID,
		arg.PacketSourceClientID,
		arg.PacketSequenceNumber,
	)
	return err
}
